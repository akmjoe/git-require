#!/bin/bash

usage() {
    echo "usage: git require [options] [name <path-to-source> <path-to-destination>]"
    echo ""
    echo "Options:"
    echo "-c Copy files instead of using symbolic links"
    echo "update [-f] [name]	Update files"
    echo "remove [name]	Remove required directory"
    echo "init	Initialize and add .git-require to git exclude list"
    echo "status Display git status of remote repositories"
    echo "enable [name] Enable require"
    echo "disable [name] Disable require"
    echo "list Lists requires and require paths"
    echo
    echo "If source is a remote repository, a copy will be placed in the .git-require directory."
}

version() {
    echo "git require plugin v0.1.0"
    echo
}

status() {
	paths=()
	checked=()
	while IFS= read -r -d $'\0'; do
	    paths+=("$REPLY")
	done < <(cd .git-require && find . -maxdepth 1 -type d -print0)
	# save current directory
	home=$(realpath .)
	for f in "${paths[@]}"; do
		if [ $f == "." ]; then
			continue
		fi
		cd $home
		while IFS=$'\t' read -r from to mode; do
			cd $from
			until [ "$(exec pwd)" = / ]; do
				if [ -d .git ]; then
					if [[ $(git status -s) ]]; then
						echo -e "\e[31m`pwd` Has changes\e[0m"
					else
						echo "`pwd` up to date"
					fi
					break
				else
					cd ../
				fi
			done
		done < ".git-require/$f/info"
	done
}

remove() {
	#path="$(echo "$1" | sed -e 's,\/,-,g')"
	path=$1
	if [ ! -d ".git-require/$path" ]; then
		echo "$1 is not in the require list! Cannot remove."
		return 1
	fi
	if [ ! -f ".git-require/remove" ]; then
		touch ".git-require/remove"
	fi
	echo "$path" >> ".git-require/remove"
	echo "$1 staged for removal. Run 'git require update' to apply (Note: this cannot be undone!)"
}

able() {
	if [ ! -z $2 ]; then
		path="$(echo "$2" | sed -e 's,\/,-,g')"
		paths=($path)
	else
		paths=()
		while IFS= read -r -d $'\0'; do
		    paths+=("$REPLY")
		done < <(cd .git-require && find . -maxdepth 1 -type d -print0)
	fi
	# Loop through paths
	for f in "${paths[@]}"; do
		if [ -z $f ] || [ $f == "." ]; then
			continue
		fi
		touch ".git-require/$f/temp-info"
		while IFS=$'\t' read -r from to mode status; do
			# Looping through file entries, enabling
			if [ "$1" == "true" ]; then
				echo -e "$from\t$to\t$mode\ttrue" >> ".git-require/$f/temp-info"
			else
				echo -e "$from\t$to\t$mode\tfalse" >> ".git-require/$f/temp-info"
			fi
		done < ".git-require/$f/info"
		# now remove info and rename temp-info to info
		rm ".git-require/$f/info"
		mv ".git-require/$f/temp-info" ".git-require/$f/info"
		if [ "$1" == "true" ]; then
			echo "$f Enabled"
		else
			echo "$f Disabled"
		fi
	done
	echo "Run git require update to activate these changes."
}

list() {
	# Get paths
	paths=()
	while IFS= read -r -d $'\0'; do
	    paths+=("$REPLY")
	done < <(cd .git-require && find . -maxdepth 1 -type d -print0)
	# Loop through paths
	for f in "${paths[@]}"; do
		if [ -z $f ] || [ $f == "." ]; then
			continue
		fi
		echo "$(echo "$f" | sed -e 's,.\/,,')"
		while IFS=$'\t' read -r from to mode status; do
			# Looping through file entries
			if [ "$status" == "true" ]; then
				echo -e "|--$from \e[42mEnabled\e[0m"
			else
				echo -e "|--$from \e[41mDisabled\e[0m"
			fi
		done < ".git-require/$f/info"
	done
}

removals() {
	if [ ! -f ".git-require/remove" ]; then
		return 1;
	fi
	# Loop through removals
	while IFS=$'\n' read -r f; do
		# Loop through files, removing them
		while IFS=$'\n' read -r file; do
			rm "$file"
		done < ".git-require/$f/list"
		# Remove require directory
		rm -r ".git-require/$f"
	done < ".git-require/remove"
	# Remove list
	rm ".git-require/remove"
	return 0
}

require() {
	path="$2"
	if [ -z $3 ]; then
		echo "No file path specified!"
		return 1;
	fi
	if [ ! -d $3 ] && [ ! -f $3 ]; then
		echo "Source file does not exist!"
		return 1;
	fi
	#path="$(echo "$3" | sed -e 's,\/,-,g')"
	if [ ! -d ".git-require/$path" ]; then
		mkdir ".git-require/$path"
	fi
	if [ ! -f ".git-require/$path/info" ]; then
		touch ".git-require/$path/info"
	fi
	if [ ! -f ".git-require/$path/list" ]; then
		touch ".git-require/$path/list"
	fi
	if [ -z $4 ]; then
		to="."
	else
		to=$4
	fi
	echo -e "$3\t$to\t$1\ttrue" >> ".git-require/$path/info"
	
	echo "Added $3 to require path. Run 'git require update' to copy files."
}

update() {
	# First remove any staged removals
	if [ -f ".git-require/remove" ]; then
		removals
	fi
	# Now proceed with the update
	if [ ! -z $2 ]; then
		path="$(echo "$2" | sed -e 's,\/,-,g')"
		paths=($path)
	else
		paths=()
		while IFS= read -r -d $'\0'; do
		    paths+=("$REPLY")
		done < <(cd .git-require && find . -maxdepth 1 -type d -print0)
	fi
	# clear conflicts file
	true > ".git-require/conflicts.log"
	# Loop through paths
	for f in "${paths[@]}"; do
		if [ -z $f ] || [ $f == "." ]; then
			continue
		fi
		# Get exclude list
		IFS=$'\n' read -d '' -r -a exclude < .git-require/exclude
		e="-path */.git"
		for p in "${exclude[@]}"; do
			if [ ! -z $p ]; then
				e+=" -o -path $p"
			fi
		done
		touch ".git-require/$f/tmp-list"
		IFS=$'\n' read -d '' -r -a files < ".git-require/$f/list"
		# Loop through destinations
		while IFS=$'\t' read -r from to mode status; do
			if [ "$status" == "false" ]; then
				# disabled - skip copy
				echo "$from is disabled - skipping"
				continue
			fi
			to=$(realpath $to)
			echo "Updating $from to $to"
			# Get extra exclude list
			if [ -f ".git-require/$f/exclude" ]; then
				IFS=$'\n' read -d '' -r -a exclude < ".git-require/$f/exclude"
				for p in "${exclude[@]}"; do
					if [ ! -z $p ]; then
						e+=" -o -path $p"
					fi
				done
			fi
			# Loop through files
			while IFS= read -r -d '' -u 9; do
				# update file
				mkdir -p $to/$(dirname $(realpath --relative-to=$from $REPLY))
				if [ -f $to/$(realpath --relative-to=$from $REPLY) ] || [ -d $to/$(realpath --relative-to=$from $REPLY) ]; then
					# Check if file should exist

					containsElement "$to/$(realpath --relative-to=$from $REPLY)" "${files[@]}"
					if [ $? == "1" ] && [ "$1" == "false" ]; then
						# Not from this require - file conflict. Skip.
						conflict=true
						echo "File conflict: $to/$(realpath --relative-to=$from $REPLY) exists!"
						echo "$to/$(realpath --relative-to=$from $REPLY)" >> ".git-require/conflicts.log"
						continue
					fi
				fi
				if [ $mode == "true" ]; then
					#echo "Copying $REPLY"
					cp $(realpath $REPLY) $to/$(realpath --relative-to=$from $REPLY)
				else
					#echo "Making link to $REPLY"
					ln -s -f $(realpath $REPLY) $to/$(realpath --relative-to=$from $REPLY)
				fi
				# Add to file list
			   echo "$to/$(realpath --relative-to=$from $REPLY)" >> ".git-require/$f/tmp-list"
			done 9< <( find $from \( $e \) -prune -o -type f -exec printf '%s\0' {} + )
		done < ".git-require/$f/info"
		# Remove extra files
		IFS=$'\n' read -d '' -r -a files < ".git-require/$f/tmp-list"
		while IFS=$'\n' read -r old; do
			# Check if file in new list
			containsElement "$old" "${files[@]}"
			if [ $? == "1" ]; then
				#echo "Removing $old"
				rm "$old"
			fi
		done < ".git-require/$f/list"
		# update file list
		rm ".git-require/$f/list"
		mv ".git-require/$f/tmp-list" ".git-require/$f/list"
	done
	if [ $conflict ]; then
		echo -e "\e[31mSome conflicting files were not copied, use -f option to overwrite.\e[0m"
	fi
}

initialize() {
	if [ ! -d ".git-require" ]; then
		echo "Initializing git-require";
		mkdir ".git-require"
	fi
	if [ ! -f ".git-require/exclude" ]; then
		touch ".git-require/exclude"
	fi
	return 0
	# Below is disabled - can be done manually if desired.
	if [ ! -f ".gitignore" ]; then
		echo "Creating exclude file"
		touch ".gitignore"
	fi
	input="$PWD/.gitignore"
	while IFS= read line; do
		if [ $line == ".git-require" ]; then
			echo "Already in exclude list."
			echo "Done initializing."
			return 0;
		fi
	done <"$input"
	echo "Adding to exclude list"
	echo ".git-require" >> ".gitignore"
	echo "Done initializing."
}

containsElement () {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

main() {
	# make sure a git directory
	if [ ! -d ".git" ]; then
		echo "This is not a git directory! Please run 'git init' and try again.";
	fi
	copy=false
	action=""
	force=false
 	# Check parameters
	while (( "$#" )); do
		case $1 in
			"status")
				status; exit 0
				;;
			"-h"|"--help")
				usage; exit 0
				;;
			"-v"|"--version")
				version; exit 0
				;;
			"-l"|"list")
				list; exit 0
				;;
			"-c"|"copy")
				copy=true
				;;
			"-u"|"update")
				action="update"
				;;
			"-f"|"force")
				force=true
				;;
			"-r"|"remove")
				shift
				while (( "$#" )); do
					remove "$1"
					shift
				done
				exit 0
				;;
			"-i"|"init")
				initialize; exit 0
				;;
			"-e"|"enable")
				shift
				if (( ! "$#" )); then able "true"; fi
				while (( "$#" )); do
					able "true" "$1"
					shift
				done
				exit 0
				;;
			"-d"|"disable")
				shift
				if (( ! "$#" )); then able "false"; fi
				while (( "$#" )); do
					able "false" "$1"
					shift
				done
				exit 0
				;;
			*)
				name="$1"
				shift
				path="$1"
				shift
				dest="$1"
		esac
		shift
   done
	if [ ! -d ".git-require" ]; then
		echo "Not a git-require directory! Run 'git require init' and try again."
		return 0
	fi
	# Now handle the command
	case $action in
		"update")
			update "$force" "$name"
			;;
		*)
			if [ -z "$path" ]; then
				echo "Invalid command!"
				usage; exit 1
			fi
			require "$copy" "$name" "$path" "$dest"
			;;
	esac
	
}

main "$@"
